### spring：拦截器适配器-HandlerInterceptorAdapter

```java
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter

public interface HandlerInterceptor{
    
    boolean preHandler(HttpServletRequest request, HttpServletResponse response, Object handler) throw Exception;
    
    void postHandler(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAnd View) throw Exception;
    
    void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throw Exception;
}

public class HandlerInterceptorAdapter implements AsyncHandlerInterceptor{
    @Override
    boolean preHandler(HttpServletRequest request, HttpServletResponse response, Object handler) throw Exception{
        return true;
    }
    
    @Override
    void postHandler(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAnd View) throw Exception{
        
    }
    
    @Override
    void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throw Exception{
        
    }
}
```

应用场景：

+ 日志记录：记录请求信息的日志，以便进行信息监控、信息统计等
+ 权限检查：登陆检测
+ 性能监控：慢日志

运行流程：

+ 拦截器执行顺序是按照 Spring 配置文件中定义的顺序而定的
+ 会先按照顺序执行所有拦截器的 preHandler方法，一直到 return false 为止，如第二个 preHandler 方法是 return false，则第三个以及以后所有拦截器都不会执行。若都是 return true，则按顺序加载完 preHandler 方法。
+ 然后执行主方法（自己的 controller 接口），若中间抛出异常，则跟 return false效果一致，不会继续执行postHandle，只会倒序执行afterCompletion方法。
+ 在主方法执行完业务逻辑（页面还未渲染数据）时，按倒序执行postHandle方法。若第三个拦截器的preHandle方法return false，则会执行第二个和第一个的postHandle方法和afterCompletion（**postHandle都执行完才会执行这个**，也就是页面渲染完数据后，执行after进行清理工作）方法。（postHandle和afterCompletion都是倒序执行）

注册：

WebMvcConfigurerAdapter 抽象类（对 WebMvcConfigurer 接口的简单实现）—— springboot 2.0，spring5.0 已废弃

直接实现 WebMvcConfigurer

直接继承 WebMvcConfigurationSupport

```java
@Override
public void addInterceptors(InterceptorRegistry registry){
    registry.addInterceptor(new LogInterceptor());
    registry.addInterceptor(new LogInterceptor2());
}
```

