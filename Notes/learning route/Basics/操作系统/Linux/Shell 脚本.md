# Shell 脚本

​        shell是外壳的意思，就是操作系统的外壳。我们可以通过shell命令来操作和控制操作系统，比如Linux中的Shell命令就包括ls、cd、pwd等等。总结来说，Shell是一个命令解释器，它通过接受用户输入的Shell命令来启动、暂停、停止程序的运行或对计算机进行控制。

​        shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。

​        shell 本身并不是内核的一部分，它只是站在内核的基础上编写的一个应用程序。

## 基本变量

- ## 变量类型  

  运行shell时，会同时存在三种变量：

1. 局部变量：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。

2. 环境变量：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。

3. shell变量：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行  

   ------

   

- ### 变量操作  

  1.创建普通变量： name="test" **（=两边不可有空格）**

  2.创建只可函数体中使用的局部变量： local name="test" （使用**local**修饰的变量在函数体外无法访问，并且local只能在函数体内使用）

  3.使用变量： **echo** $name 或者 **echo** ${name} （推荐使用大括号版）

  4.变量重新赋值： name="new_test" （将原值覆盖）

  5.只读变量： name="only_read" -> **readonly** name （使用readonly标识后的变量，不可被修改）

  6.删除变量： **unset** name; （删除之后不可访问，删除不掉只读变量） 
  
  ------
  
  

+ ### 字符串变量

1）单引号

- 单引号变量var='test' ，只能原样输出，变量无效
- 单引号中不能出现一个单独的单引号，转义也不可以

2）双引号

- 双引号变量var="my name is ${name}"，变量有效
- 可出现转义符

3）拼接字符串

- 中间无任何+，之类的字符
- name="this is"" my name"; name="this is my name"; name="this" is "my name" 等效
- name='this is'' my nam'; name='this is my name'; name='this' is 'my name' 等效

4）获取字符串长度

- 在${}中**使用“#”获取长度**
- name="test";
- echo ${#name}; # 输出为4

5）提取子字符串

- 1:4 从第2个开始 往后截取4个字符

- ::4 从第一个字符开始 往后截取4个字符

  ```shell
      name="this is my name";
  
      echo ${name:1:4} #输出 is i
  
      echo ${name::4} #输出 this 
  ```

  ------

  调试`index:num ` 或者`::num`的时候，需要使用bash脚本来运行，在shell头部添加`#! bin/bash`


+ ### 数组  

  bash只支持一维数组，不支持多维数组
- 定义数组：```array_name=(li wang xiang zhang)``` （小括号做边界、使用空格分离）

- 单独定义数组的元素： ```array_para[0]="w"; array_para[3]="s"``` （定义时下标不连续也可以）

- 赋值数组元素：`array_name[0]="zhao";`

- 获取数组元素：  

  ```shell
  	array_name[3]="zhang"
      echo ${array_name[0]} # 输出"li"
      echo ${array_name[1]} # 输出" "
      echo ${array_name[3]} # 输出"zhang"
      echo ${array_name[@]} # 输出"li zhang" 输出数组所有元素，没有元素的下标省略
  ```


  - 取得元素个数：```${#array_name[@]}``` 或者``` ${#array_name}```
  - 取得单个元素长度：${#array_name[1]}

## 参数传递  
  - 获取参数值：  
    - $0 ： 固定，代表执行的文件名
    - $1 ： 代表传入的第1个参数
    - $n ： 代表传入的第n个参数

  

  - \$#：参数个数

  - \$*： 以一个单字符串显示所有向脚本传递的参数。如"$"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数

  - \$@：与$*相同，但是使用时加引号，并在引号中返回每个参数。

  - \$\$：脚本运行的当前进程号

  - \$！：后台运行的最后一个进程的ID

  - \$?： 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。

  - \$* 与 $@ 区别

    - 相同点：都是引用所有参数。
    - 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）。

  运算符

## 算数运算

  - \+ 、-、*、\ ： 乘号前必须加\进行转义才可以进行乘法运算

  - 加法运算

  - - val=${expr 2 + 2} （使用linux命令expr进行辅助运算）
    - val=$[2+2] （4个空格不是必要的，不同于条件判断）
    - val=$((2+2))  

| 运算操作符/运算命令 |                             说明                             |
| ------------------- | :----------------------------------------------------------: |
| (())                |            用于整数运算，效率很高，**推荐使用**。            |
| let                 |                 用于整数运算，和 (()) 类似。                 |
| $[]                 |                用于整数运算，不如 (()) 灵活。                |
| expr                |                                                              |
| bc                  | Linux下的一个计算器程序，可以处理整数和小数。Shell 本身只支持整数运算，想计算小数就得使用 bc 这个外部的计算器。 |
| declare             | 将变量定义为整数，然后再进行数学运算时就不会被当做字符串了。功能有限，仅支持最基本的数学运算（加减乘除和取余），不支持逻辑运算、自增自减等，所以在实际开发中很少使用。 |

------



## 数字关系运算符

  关系运算符只支持数字，不支持字符串，除非字符串的值是数字。
  下面假定变量 a 为 10，变量 b 为 20

  - -eq ：检测两个数是否**相等**，相等返回 true。 [ $a -eq $b ] 返回 false。
  - -ne： 检测两个数是否**不相等**，不相等返回 true。 [ $a -ne $b ] 返回 true。
  - -gt： 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。
  - -lt ： 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。
  - -ge： 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。
  - -le ： 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。
    **字符串运算符**
    下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：
  - = ：检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。
  - != ：检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。
  - -z ：检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。
  - -n ：检测字符串长度是否为0，不为0返回 true。 [ -n "$a" ] 返回 true。
  - $ ：检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。
    **布尔运算符**
    下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：
  - ! ：非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。
  - -o ：或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。
  - -a ：与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。

  **逻辑运算符**
  以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:

  - && ：逻辑的 AND [[ $a -lt 100 && $b -gt 100 ]] 返回 false
  - || ：逻辑的 OR [[ $a -lt 100 || $b -gt 100 ]] 返回 true

------



## 定义函数

可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。

- **函数定义**[ function ] funname() { action; [return int;] }

- **参数传递**

- - 调用函数: fun_name 2 3 4
  - 函数中使用：和shell取用函数相同 $n $# $* $? 或者加上{}funWithParam(){ echo "第一个参数为 $1 !" echo "第二个参数为 $2 !" echo "第十个参数为 $10 !" echo "第十个参数为 ${10} !" echo "第十一个参数为 ${11} !" echo "参数总数有 $# 个!" echo "作为一个字符串输出所有参数 $* !"} funWithParam 1 2 3 4 5 6 7 8 9 34 73 echo $? \# 判断执行是否成功

- ## 函数返回值

- return字样可存在也可不存在
- return 只能为 return [0-255]，此处的返回可作为函数执行的状态，通过$?获取的便是这个返回值
- 如果不加return ， 则默认最后一条语句的执行状态所为函数执行状态的返回值，如果最后一条语句执行成功，则$?为0，否则不为0

- 使用函数返回值（Janusgraph图数据库官方启动服务脚本片段）

- return返回的数字，只是作为函数执行状态的返回值，也就是接下来$?获取的值
  - 对于类似于下面的BIN=\abs_path``语句，获取的是函数体内所有的echo、printf输出组合成的一个字符串 abs_path() { SOURCE="${BASH_SOURCE[0]}" while [ -h "$SOURCE" ]; do DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )" SOURCE="$(readlink "$SOURCE")" [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" done echo "test" echo "$( cd -P "$( dirname "$SOURCE" )" && pwd )" **#** 此函数的两个echo输出会组合成一个字符串作为下述BIN的值 }