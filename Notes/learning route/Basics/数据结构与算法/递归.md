# 递归

对实际问题中反复出现的结构和形式做高度概括，并从本质层面加以描述和刻画，进而导出高效的算法。

程序结构：

递归能够统筹纷繁多变的具体情况，避免复杂的分支以及嵌套的循环，从而更为简明地描述和实现算法，减少代码量，提高算法的可读性，保证算法的整体效率。

不同的递归形式：

+ 线性递归
+ 二分递归
+ 多分支递归

等，以实现（遍历、分治等）算法策略

如何利用**递归跟踪**和**递推方程**等方法分析递归算法的复杂度。



## 线性递归

### 数组求和

```java
// 数组求和算法（线性递归版）
int sum(int[] A, int n){
    // 平凡情况，递归基
    if(1 > n)
        // 直接，非递归式计算
        return 0;
    else
        // 递归：前 n - 1 项之和，再累计第 n - 1 项
        return sum(A, n - 1) + A[n - 1];
}
```

保证递归算法有穷性的基本技巧：

首先判断并处理 n = 0 之类的平凡情况，以避免因无限递归而导致系统溢出。递归基（base case of recursion），平凡情况可能有多种，但至少要有一种，且迟早必然会出现。



### 线性递归——linear recursion

每一递归实例对自身的调用至多一次。构成一个线性的次序关系。

递归的最基本形式

两个独立子问题：

+ 对应于单独的某个元素，可直接求解
+ 对应于剩余部分，且其结构与原问题相同

子问题的解经简单的合并（如整数相加）之后，即可得到原问题的解。



### 减而治之-分而治之

decrease-and-conquer

递归每深入一层，待求解问题的规模都缩减一个常数，直至最终退化为平凡的小（简单）问题。



## 递归分析

递归算法 时间和空间复杂度的分析

递归跟踪，递推方程

### 递归跟踪——recursion trace

### 递推方程



## 递归模式

### 多递归基

数组倒置问题：

```c
// 重置的倒置算法的原型
void reverse(int*, int, int);
// 数组倒置（算法的初始入口，调用的可能是 reverse() 的递归版或迭代版
void reverse(int* A, int n){
    reverse(A, 0, n - 1);
}
// 数组倒置（多递归基递归版）
void reverse(int* A, int lo, int hi){
    if(lo < hi){
        // 交换 A[lo] 和 A[hi]
        swap(A[lo], A[hi]);
        // 递归倒置A(lo, hi)
        reverse(A, lo + 1, hi - 1);
    }
    // else 隐含了两种递归基
}// O(hi - lo + 1)
```



### 实现递归

从多个角度反复尝试， 确定对问题的输入及其规模的最佳划分方式

可能需要从不同的角度重新定义和描述原问题，使得经分解所得的子问题与原问题具有相同的语义形式。  

线性递归版reverse()算法中，通过引入参数lo和hi，使得对全数组以及其后各子数组的递归调用都统一为相同的语法形式。另外，还利用C++的函数重载（overload）机制定义了名称相同、参数表有别的另一函数reverse(A, n)，作为统一的初始入口  

### 多向递归

递归调用可能有可供选择的分支

如果每一递归实例虽有多个可能的递归方向，但只能从中选择其一，故各层次上的递归实例依然构成一个线性次序关系，仍属于线性递归



实例：计算幂函数 power(2, n) = 2 ^ n

该函数的重新定义和表述：

power2(n) = 1	(n = 0)

​					 power2(n-1) x 2	(else)

O(n)次递归调用，与蛮力求解相同

power2(n) = 1	(n = 0)

​					 power2(n / 2)^2 x 2	(n > 0 and odd)

​					power2(n / 2) ^ 2		(n > 0 and even)

## 递归消除

消耗空间，影响实际速度

运行速度要求极高、存储空间需要精打细算的场合，往往应将递归算法改写成等价的非递归版本

一般转换思路：利用栈结构模拟操作系统的工作过程

### 尾递归及消除

若递归调用在递归实例中恰好以最后一步操作的形式出现，则称作尾递归（tail recursion）

属于尾递归形式的算法，均可以简捷地转换为等效的迭代版本。  

```c
void reverse(int* A, int lo, int hi){
    while(lo < hi){
        // 交换 A[lo] 和 A[hi]
        swap(A[lo], A[hi]);
        // 递归倒置A(lo, hi)
        // reverse(A, lo + 1, hi - 1);
        lo++;
        hi--;
    }
    // else 隐含了两种递归基
}// O(hi - lo + 1)
```

递归语句出现在代码体的最后一行， 并不见得就是尾递归；严格地说，只有当该算法（除平凡递归基外）任一实例都终止于这一递归调用时，才属于尾递归。  



## 二分递归

凡治众如治寡，分数是也  

与减而治之策略一样，这里也要求对原问题重新表述，以保证子问题与原问题在接口形式上的一致。 既然每一递归实例都可能做多次递归，故称作“**多路递归**”（multi-way recursion） 。通常都是将原问题一分为二，故称作“二分递归” （binary recursion） 。需强调的是，无论是分解为两个还是更大常数个子问题，对算法总体的渐进复杂度并无实质影响。  

数组求和，二分递归版：

```java
int sum(int[] A, int lo, int hi){
    if(lo == hi){
        // 遇到递归基（区间长度已降至 1）
        return A[lo];
    }
    else{
        // 一般情况下 lo < hi，则
        int mi = (lo + hi) >> 1;
        // 递归对各子数组求和，然后合计
        return sum(A, lo, mi) + sum(A, mi + 1, hi);
    }
}// O(hi - lo + 1)，线性正比于区间的长度
```

### 分而治之

### 数组求和

### 效率

### Fibonacci数：线性递归

### Fibonacci数：迭代

## 抽象数据类型

封装
