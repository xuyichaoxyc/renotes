# 递归

对实际问题中反复出现的结构和形式做高度概括，并从本质层面加以描述和刻画，进而导出高效的算法。

程序结构：

递归能够统筹纷繁多变的具体情况，避免复杂的分支以及嵌套的循环，从而更为简明地描述和实现算法，减少代码量，提高算法的可读性，保证算法的整体效率。

不同的递归形式：

+ 线性递归
+ 二分递归
+ 多分支递归

等，以实现（遍历、分治等）算法策略

如何利用**递归跟踪**和**递推方程**等方法分析递归算法的复杂度。



## 线性递归

### 数组求和

```java
// 数组求和算法（线性递归版）
int sum(int[] A, int n){
    // 平凡情况，递归基
    if(1 > n)
        // 直接，非递归式计算
        return 0;
    else
        // 递归：前 n - 1 项之和，再累计第 n - 1 项
        return sum(A, n - 1) + A[n - 1];
}
```

保证递归算法有穷性的基本技巧：

首先判断并处理 n = 0 之类的平凡情况，以避免因无限递归而导致系统溢出。递归基（base case of recursion），平凡情况可能有多种，但至少要有一种，且迟早必然会出现。



### 线性递归——linear recursion

每一递归实例对自身的调用至多一次。构成一个线性的次序关系。

递归的最基本形式

两个独立子问题：

+ 对应于单独的某个元素，可直接求解
+ 对应于剩余部分，且其结构与原问题相同

子问题的解经简单的合并（如整数相加）之后，即可得到原问题的解。



### 减而治之-分而治之

decrease-and-conquer

递归每深入一层，待求解问题的规模都缩减一个常数，直至最终退化为平凡的小（简单）问题。



## 递归分析

递归算法 时间和空间复杂度的分析

递归跟踪，递推方程

### 递归跟踪——recursion trace

### 递推方程



## 递归模式

### 多递归基

数组倒置问题：

```c
// 重置的倒置算法的原型
void reverse(int*, int, int);
// 数组倒置（算法的初始入口，调用的可能是 reverse() 的递归版或迭代版
void reverse(int* A, int n){
    reverse(A, 0, n - 1);
}
// 数组倒置（多递归基递归版）
void reverse(int* A, int lo, int hi){
    if(lo < hi){
        // 交换 A[lo] 和 A[hi]
        swap(A[lo], A[hi]);
        // 递归倒置A(lo, hi)
        reverse(A, lo + 1, hi - 1);
    }
    // else 隐含了两种递归基
}// O(hi - lo + 1)
```







