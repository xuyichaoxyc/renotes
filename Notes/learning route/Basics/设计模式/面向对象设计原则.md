## 1. 开闭原则

软件实体：

+ 项目中划分出的模块
+ 类与接口
+ 方法

self：对增加开放，对修改关闭

standard：对扩展开放，对修改关闭

+ 对软件测试的影响
+ 可复用性
+ 可维护性：稳定性高，延续性强，从而易于扩展和维护

实现方法：

“抽象约束、封装变化”

通过接口和抽象类为软件实体定义一个相对稳定的抽象层，将相同的可变因素封装在相同的具体实现类中

## 2. 里氏替换原则

standard：继承必须确保超类所拥有的性质在子类中依然成立

作用：

+ 里氏替换原则是实现开闭原则的重要方式之一
+ 克服了继承中重写父类造成的可复用性变差的缺点
+ 动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性

通俗来讲：子类可以扩展父类的功能，但不能改变父类原有的功能

子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法



## 3. 依赖倒置原则

standard：

​	高层模块不应该依赖底层模块，两者都应该依赖其抽象；

​	抽象不应该依赖细节，细节应该依赖抽象。

依赖倒置原则是实现开闭原则的重要途径之一。

抽象：接口或者抽象类

细节：具体的实现类

作用：

+ 降低类间的耦合性
+ 提高系统的稳定性
+ 减少并行开发引起的风险
+ 提高代码的可读性和可维护性



依赖倒置原则应该遵循的原则：

+ 每个类尽量提供接口或抽象类，或者两者都具备
+ 变量的声明类型尽量是接口或抽象类
+ 任何类不应该从具体类派生
+ 使用继承时尽量遵循里氏替换原则

```java
class Customer{
    public void shopping(ShaoguanShop shop){
        // 购物
        System.out.println(shop.sell());
    }
}

class Customer{
    public void shopping(Wuyuan shop){
        // 购物
        System.out.println(shop.sell());
    }
}
```

```java
class Customer{
    public void shopping(Shop shop){
        // 购物
        System.out.println(shop.sell());
    }
}
interface Shop{
    // 卖
    public String sell();
}
class ShaoguanShop implements Shop{
    public String sell(){
        return "韶关土特产：香菇、木耳……";
    }
}
class WuyuanShop implements Shop{
    public String sell(){
        return "婺源土特产：绿茶、酒糟鱼……";
    }
}

public class DIPtest{
    public static void main(String[] args){
        Customer Wang = new Customer();
        System.out.println("顾客购买以下商品：");
        wang.shopping(new ShaoguanShop());
        wang.shopping(new WuyuanShop());
    }
}
```



## 4. 单一职责原则

职责：类变化的原因

standard：一个类应该有且只有一个引起它变化的原因，否则类应该被拆分

如果一个对象承担了太多职责，缺点：

+ 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
+ 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全部包含进来，从而造成冗余代码或代码的浪费

单一职责原则的核心：控制类的粒度大小、将对象解耦、提高其内聚性。

优点：

+ 降低类的复杂度。一个类只负责一项原则，其逻辑肯定比负责多项职责简单的多
+ 提高类的可读性。复杂性降低，自然其可读性会提高
+ 提高系统的可维护性。可读性提高，更容易维护
+ 变更引起的风险降低。

实现方法：

类、方法

## 5. 接口隔离原则

庞大接口拆分，更小和更具体的接口，让接口中只包含用户感兴趣的方法

一个类对另一个类的依赖应该建立在最小的接口上

## 6. 迪米特法则



## 7. 合成复用原则

## 8. 7种设计原则的要点